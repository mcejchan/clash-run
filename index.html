<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clash Royale Hra</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: #2d3436;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
        }
        
        #gameCanvas {
            border: 3px solid #fdcb6e;
            background: #55efc4;
            box-shadow: 0 0 20px rgba(253, 203, 110, 0.5);
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="info">
        <strong>Ovl√°d√°n√≠:</strong><br>
        WASD nebo ≈°ipky = pohyb<br>
        Pozice: <span id="position">0, 0</span><br>
        <strong>Tvoje arm√°da:</strong><br>
        üèπ Lukost≈ôelec: <span id="archer-hp">100</span> HP<br>
        üíö L√©ka≈ô: <span id="healer-hp">80</span> HP<br>
        <br>
        <strong style="color: #e74c3c;">‚ö†Ô∏è Nep≈ô√≠tel:</strong><br>
        ü§ñ Robot: <span id="robot-hp">150</span> HP
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        // Parser pro config.properties
        let CONFIG = {};

        function loadConfigSync() {
            // Synchronn√≠ naƒç√≠t√°n√≠ s fallback na v√Ωchoz√≠ hodnoty
            try {
                // Pokus o synchronn√≠ fetch (fallback, pokud config.properties nen√≠ dostupn√Ω)
                fetch('config.properties')
                    .then(response => response.text())
                    .then(text => {
                        const lines = text.split('\n');
                        lines.forEach(line => {
                            line = line.trim();
                            if (!line || line.startsWith('#')) return;

                            const [key, value] = line.split('=');
                            if (!key || !value) return;

                            let parsedValue = value.trim();
                            if (parsedValue === 'true') parsedValue = true;
                            else if (parsedValue === 'false') parsedValue = false;
                            else if (!isNaN(parsedValue) && parsedValue !== '') {
                                parsedValue = parseFloat(parsedValue);
                            }

                            const keys = key.trim().split('.');
                            let obj = CONFIG;
                            for (let i = 0; i < keys.length - 1; i++) {
                                obj[keys[i]] = obj[keys[i]] || {};
                                obj = obj[keys[i]];
                            }
                            obj[keys[keys.length - 1]] = parsedValue;
                        });
                        console.log('Config naƒçten:', CONFIG);
                    })
                    .catch(error => {
                        console.warn('Config.properties nebyl nalezen, pou≈æ√≠v√°m v√Ωchoz√≠ hodnoty:', error);
                    });
            } catch (error) {
                console.warn('Chyba p≈ôi naƒç√≠t√°n√≠ configu:', error);
            }
        }

        // Naƒç√≠st konfiguraci (asynchronnƒõ, bez blokov√°n√≠)
        loadConfigSync();

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Nastavit v√Ωchoz√≠ rozmƒõry - config se naƒçte asynchronnƒõ
        canvas.width = 800;
        canvas.height = 600;
        
        // Hr√°ƒç (uprost≈ôed obrazovky)
        const player = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            width: CONFIG.player?.width || 40,
            height: CONFIG.player?.height || 50,
            speed: CONFIG.player?.speed || 4,
            color: CONFIG.player?.color || '#e74c3c'
        };
        
        // Posun svƒõta (nekoneƒçn√° plocha)
        const world = {
            offsetX: 0,
            offsetY: 0
        };
        
        // Tvoje postavy (spojenci)
        const allies = [
            {
                name: 'Lukost≈ôelec',
                x: canvas.width / 2 - 40,
                y: canvas.height / 2 + 60,
                worldX: -40,
                worldY: 60,
                width: CONFIG.archer?.width || 35,
                height: CONFIG.archer?.height || 45,
                speed: CONFIG.archer?.speed || 2.8,
                color: CONFIG.archer?.color || '#27ae60',
                hp: CONFIG.archer?.hp || 100,
                maxHp: CONFIG.archer?.maxHp || 100,
                attackTimer: 0,
                attackCooldown: CONFIG.archer?.attackCooldown || 60,
                attackRange: CONFIG.archer?.attackRange || 200,
                damage: CONFIG.archer?.damage || 15
            },
            {
                name: 'L√©ka≈ô',
                x: canvas.width / 2 + 60,
                y: canvas.height / 2 + 40,
                worldX: 60,
                worldY: 40,
                width: CONFIG.healer?.width || 35,
                height: CONFIG.healer?.height || 45,
                speed: CONFIG.healer?.speed || 3,
                color: CONFIG.healer?.color || '#3498db',
                hp: CONFIG.healer?.hp || 80,
                maxHp: CONFIG.healer?.maxHp || 80,
                healTimer: 0,
                healCooldown: CONFIG.healer?.healCooldown || 90,
                healAmount: CONFIG.healer?.healAmount || 10
            }
        ];
        
        // Nep≈ô√°telsk√Ω robot
        const enemies = [
            {
                name: 'Robot',
                worldX: 200,
                worldY: -100,
                width: CONFIG.robot?.width || 45,
                height: CONFIG.robot?.height || 55,
                speed: CONFIG.robot?.speed || 1.5,
                color: CONFIG.robot?.color || '#95a5a6',
                hp: CONFIG.robot?.hp || 150,
                maxHp: CONFIG.robot?.maxHp || 150,
                attackTimer: 0,
                attackCooldown: CONFIG.robot?.attackCooldown || 80,
                attackRange: CONFIG.robot?.attackRange || 60,
                damage: CONFIG.robot?.damage || 12,
                slowDownTimer: 0,
                slowDownInterval: Math.random() * (CONFIG.robot?.slowDownMaxInterval || 300) + (CONFIG.robot?.slowDownMinInterval || 100),
                isSlow: false,
                isAttacking: false
            }
        ];
        
        const keys = {};
        const projectiles = [];
        const obstacles = [];

        // Generuj n√°hodn√© p≈ôek√°≈æky
        function generateObstacles() {
            const minObstacles = CONFIG.obstacles?.count?.min || 15;
            const maxObstacles = CONFIG.obstacles?.count?.max || 20;
            const obstacleCount = Math.floor(Math.random() * (maxObstacles - minObstacles + 1)) + minObstacles;
            const mapWidth = CONFIG.map?.worldWidth || 2000;
            const mapHeight = CONFIG.map?.worldHeight || 2000;
            const minWidth = CONFIG.obstacles?.minWidth || 60;
            const maxWidth = CONFIG.obstacles?.maxWidth || 100;
            const minHeight = CONFIG.obstacles?.minHeight || 60;
            const maxHeight = CONFIG.obstacles?.maxHeight || 100;
            const minDistance = CONFIG.obstacles?.minDistance || 200;
            const minDistanceFromUnits = CONFIG.obstacles?.minDistanceFromUnits || 250;

            for (let i = 0; i < obstacleCount; i++) {
                let obstacle;
                let valid = true;

                do {
                    valid = true;
                    obstacle = {
                        worldX: Math.random() * mapWidth - (mapWidth / 2),
                        worldY: Math.random() * mapHeight - (mapHeight / 2),
                        width: minWidth + Math.random() * (maxWidth - minWidth),
                        height: minHeight + Math.random() * (maxHeight - minHeight),
                        color: CONFIG.obstacles?.color || '#7f8c8d'
                    };

                    // Ovƒõ≈ô vzd√°lenost od jin√Ωch p≈ôek√°≈æek
                    for (let obstacle2 of obstacles) {
                        const dx = obstacle.worldX - obstacle2.worldX;
                        const dy = obstacle.worldY - obstacle2.worldY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < minDistance) {
                            valid = false;
                            break;
                        }
                    }

                    // Ovƒõ≈ô vzd√°lenost od jednotek (Lukost≈ôelec a L√©ka≈ô)
                    if (valid) {
                        for (let ally of allies) {
                            const dx = obstacle.worldX - ally.worldX;
                            const dy = obstacle.worldY - ally.worldY;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < minDistanceFromUnits) {
                                valid = false;
                                break;
                            }
                        }
                    }

                    // Ovƒõ≈ô vzd√°lenost od nep≈ô√≠tele (Robot)
                    if (valid) {
                        for (let enemy of enemies) {
                            const dx = obstacle.worldX - enemy.worldX;
                            const dy = obstacle.worldY - enemy.worldY;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < minDistanceFromUnits) {
                                valid = false;
                                break;
                            }
                        }
                    }
                } while (!valid);

                obstacles.push(obstacle);
            }
        }

        generateObstacles();

        // Detekce kolize mezi kruhovou entitou a obd√©ln√≠kem (p≈ôek√°≈ækou)
        function checkCollisionWithObstacles(x, y, radius) {
            for (let obstacle of obstacles) {
                // Nejbli≈æ≈°√≠ bod na obd√©ln√≠ku k entitƒõ
                const closestX = Math.max(obstacle.worldX - obstacle.width / 2,
                                         Math.min(x, obstacle.worldX + obstacle.width / 2));
                const closestY = Math.max(obstacle.worldY - obstacle.height / 2,
                                         Math.min(y, obstacle.worldY + obstacle.height / 2));

                const dx = x - closestX;
                const dy = y - closestY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < radius) {
                    return true; // Kolize detekov√°na
                }
            }
            return false;
        }

        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });
        
        // Vykreslen√≠ hr√°ƒçe
        function drawPlayer() {
            ctx.fillStyle = player.color;
            ctx.fillRect(
                player.x - player.width / 2,
                player.y - player.height / 2,
                player.width,
                player.height
            );
            
            ctx.fillStyle = '#f39c12';
            ctx.beginPath();
            ctx.arc(player.x, player.y - player.height / 2 - 10, 15, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(player.x - 5, player.y - player.height / 2 - 12, 4, 0, Math.PI * 2);
            ctx.arc(player.x + 5, player.y - player.height / 2 - 12, 4, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(player.x - 5, player.y - player.height / 2 - 12, 2, 0, Math.PI * 2);
            ctx.arc(player.x + 5, player.y - player.height / 2 - 12, 2, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Vykreslen√≠ zdrav√≠
        function drawHealthBar(screenX, screenY, hp, maxHp, width) {
            const barWidth = width;
            const barHeight = 5;
            const barY = screenY - 35;
            
            // Pozad√≠
            ctx.fillStyle = '#c0392b';
            ctx.fillRect(screenX - barWidth / 2, barY, barWidth, barHeight);
            
            // Aktu√°ln√≠ zdrav√≠
            ctx.fillStyle = '#2ecc71';
            ctx.fillRect(screenX - barWidth / 2, barY, (hp / maxHp) * barWidth, barHeight);
        }
        
        // Vykreslen√≠ robota (NEP≈ò√çTEL)
        function drawRobot(enemy) {
            const screenX = enemy.worldX - world.offsetX + canvas.width / 2;
            const screenY = enemy.worldY - world.offsetY + canvas.height / 2;
            
            // Tƒõlo robota
            ctx.fillStyle = enemy.isAttacking ? '#c0392b' : (enemy.isSlow ? '#7f8c8d' : enemy.color);
            ctx.fillRect(
                screenX - enemy.width / 2,
                screenY - enemy.height / 2,
                enemy.width,
                enemy.height
            );
            
            // Hlava robota (ƒçtvercov√°)
            ctx.fillStyle = '#34495e';
            ctx.fillRect(
                screenX - 15,
                screenY - enemy.height / 2 - 20,
                30,
                20
            );
            
            // Oƒçi (ƒçerven√© LED - znamen√≠ nebezpeƒç√≠)
            ctx.fillStyle = enemy.isAttacking ? '#ff0000' : (enemy.isSlow ? '#e67e22' : '#e74c3c');
            ctx.fillRect(screenX - 10, screenY - enemy.height / 2 - 15, 6, 6);
            ctx.fillRect(screenX + 4, screenY - enemy.height / 2 - 15, 6, 6);
            
            // Ant√©na
            ctx.strokeStyle = '#34495e';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(screenX, screenY - enemy.height / 2 - 20);
            ctx.lineTo(screenX, screenY - enemy.height / 2 - 30);
            ctx.stroke();
            
            ctx.fillStyle = '#e74c3c';
            ctx.beginPath();
            ctx.arc(screenX, screenY - enemy.height / 2 - 30, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // √ötoƒçn√Ω efekt
            if (enemy.isAttacking) {
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(screenX, screenY, enemy.attackRange / 2, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Zdrav√≠
            drawHealthBar(screenX, screenY, enemy.hp, enemy.maxHp, enemy.width);
        }
        
        // Vykreslen√≠ lukost≈ôelce
        function drawArcher(ally) {
            const screenX = ally.worldX - world.offsetX + canvas.width / 2;
            const screenY = ally.worldY - world.offsetY + canvas.height / 2;
            
            if (ally.hp <= 0) return;
            
            // Tƒõlo
            ctx.fillStyle = ally.color;
            ctx.fillRect(
                screenX - ally.width / 2,
                screenY - ally.height / 2,
                ally.width,
                ally.height
            );
            
            // Hlava
            ctx.fillStyle = '#f39c12';
            ctx.beginPath();
            ctx.arc(screenX, screenY - ally.height / 2 - 10, 12, 0, Math.PI * 2);
            ctx.fill();
            
            // Luk
            ctx.strokeStyle = '#8e44ad';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(screenX + 20, screenY, 15, -Math.PI / 2, Math.PI / 2, false);
            ctx.stroke();
            
            // ≈†√≠p
            ctx.strokeStyle = '#c0392b';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(screenX + 20, screenY);
            ctx.lineTo(screenX + 35, screenY);
            ctx.stroke();
            
            // Zdrav√≠
            drawHealthBar(screenX, screenY, ally.hp, ally.maxHp, ally.width);
        }
        
        // Vykreslen√≠ l√©ka≈ôe
        function drawHealer(ally) {
            const screenX = ally.worldX - world.offsetX + canvas.width / 2;
            const screenY = ally.worldY - world.offsetY + canvas.height / 2;
            
            if (ally.hp <= 0) return;
            
            // Tƒõlo
            ctx.fillStyle = ally.color;
            ctx.fillRect(
                screenX - ally.width / 2,
                screenY - ally.height / 2,
                ally.width,
                ally.height
            );
            
            // Hlava
            ctx.fillStyle = '#f39c12';
            ctx.beginPath();
            ctx.arc(screenX, screenY - ally.height / 2 - 10, 12, 0, Math.PI * 2);
            ctx.fill();
            
            // K≈ô√≠≈æ
            ctx.fillStyle = '#2ecc71';
            ctx.fillRect(screenX - 8, screenY - 5, 16, 5);
            ctx.fillRect(screenX - 2.5, screenY - 11, 5, 16);
            
            // L√©ƒç√≠c√≠ efekt
            if (ally.healTimer > 0) {
                ctx.strokeStyle = '#2ecc71';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(screenX, screenY, 30, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.globalAlpha = 0.3;
                ctx.fillStyle = '#2ecc71';
                ctx.beginPath();
                ctx.arc(screenX, screenY, 25, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
            
            // Zdrav√≠
            drawHealthBar(screenX, screenY, ally.hp, ally.maxHp, ally.width);
        }
        
        // Vykreslen√≠ projektil≈Ø (≈°√≠py)
        function drawProjectiles() {
            projectiles.forEach(proj => {
                const screenX = proj.worldX - world.offsetX + canvas.width / 2;
                const screenY = proj.worldY - world.offsetY + canvas.height / 2;

                ctx.fillStyle = '#c0392b';
                ctx.beginPath();
                ctx.arc(screenX, screenY, 4, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // Vykreslen√≠ p≈ôek√°≈æek
        function drawObstacles() {
            obstacles.forEach(obstacle => {
                const screenX = obstacle.worldX - world.offsetX + canvas.width / 2;
                const screenY = obstacle.worldY - world.offsetY + canvas.height / 2;

                // Tƒõlo p≈ôek√°≈æky
                ctx.fillStyle = obstacle.color;
                ctx.fillRect(
                    screenX - obstacle.width / 2,
                    screenY - obstacle.height / 2,
                    obstacle.width,
                    obstacle.height
                );

                // Hraniƒçn√≠ ƒç√°ra
                ctx.strokeStyle = '#34495e';
                ctx.lineWidth = 2;
                ctx.strokeRect(
                    screenX - obstacle.width / 2,
                    screenY - obstacle.height / 2,
                    obstacle.width,
                    obstacle.height
                );
            });
        }

        // Vykreslen√≠ m≈ô√≠≈æky
        function drawGrid() {
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.lineWidth = 1;
            
            const gridSize = 50;
            
            for (let x = -world.offsetX % gridSize; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = -world.offsetY % gridSize; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }
        
        // Aktualizace nep≈ô√°tel
        function updateEnemies() {
            enemies.forEach(enemy => {
                if (enemy.hp <= 0) return;

                // Priorita na Lukost≈ôelce (nejnebezpeƒçnƒõj≈°√≠)
                let targetAlly = null;
                let targetDist = Infinity;

                allies.forEach(ally => {
                    if (ally.hp <= 0) return;
                    const dx = ally.worldX - enemy.worldX;
                    const dy = ally.worldY - enemy.worldY;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    // Up≈ôednostni Lukost≈ôelce (index 0)
                    if (ally === allies[0]) {
                        if (dist < targetDist) {
                            targetDist = dist;
                            targetAlly = ally;
                        }
                    } else if (!targetAlly || targetAlly !== allies[0]) {
                        if (dist < targetDist) {
                            targetDist = dist;
                            targetAlly = ally;
                        }
                    }
                });

                // Detekuj nebezpeƒçn√© projektily pobl√≠≈æ
                let dangerousProjectile = null;
                let minDangerDist = 150;

                projectiles.forEach(proj => {
                    const dx = proj.worldX - enemy.worldX;
                    const dy = proj.worldY - enemy.worldY;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < minDangerDist) {
                        dangerousProjectile = proj;
                        minDangerDist = dist;
                    }
                });

                const currentSpeed = enemy.isSlow ? enemy.speed * 0.3 : enemy.speed;
                let moveX = 0;
                let moveY = 0;

                // Vyhnut√≠ se projektil≈Øm - nejvy≈°≈°√≠ priorita
                if (dangerousProjectile && minDangerDist < 100) {
                    const projDx = dangerousProjectile.worldX - enemy.worldX;
                    const projDy = dangerousProjectile.worldY - enemy.worldY;
                    const projDist = Math.sqrt(projDx * projDx + projDy * projDy);

                    if (projDist > 0) {
                        // Pohyb kolmo na projektil (vpravo nebo vlevo)
                        const perpX = -projDy;
                        const perpY = projDx;
                        const perpLen = Math.sqrt(perpX * perpX + perpY * perpY);
                        moveX = (perpX / perpLen) * currentSpeed * 1.5;
                        moveY = (perpY / perpLen) * currentSpeed * 1.5;
                    }
                }
                // Norm√°ln√≠ chov√°n√≠ - pohyb k c√≠li
                else if (targetAlly) {
                    const dx = targetAlly.worldX - enemy.worldX;
                    const dy = targetAlly.worldY - enemy.worldY;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > enemy.attackRange) {
                        // Strategick√Ω pohyb - nƒõkdy obch√°z√≠
                        const circleOffset = Math.sin(Date.now() / 500) * 30;
                        const perpX = -dy;
                        const perpY = dx;
                        const perpLen = Math.sqrt(perpX * perpX + perpY * perpY);

                        moveX = ((dx / dist) * currentSpeed) + (perpX / perpLen) * circleOffset * 0.1;
                        moveY = ((dy / dist) * currentSpeed) + (perpY / perpLen) * circleOffset * 0.1;
                        enemy.isAttacking = false;
                    } else {
                        // V dosahu - √∫tok
                        moveX = 0;
                        moveY = 0;
                        enemy.attackTimer++;
                        enemy.isAttacking = true;

                        if (enemy.attackTimer >= enemy.attackCooldown) {
                            targetAlly.hp -= enemy.damage;
                            enemy.attackTimer = 0;
                        }
                    }
                } else {
                    enemy.isAttacking = false;
                }

                // Aplikuj pohyb s kontrolou koliz√≠
                if (Math.abs(moveX) > 0 || Math.abs(moveY) > 0) {
                    const moveLen = Math.sqrt(moveX * moveX + moveY * moveY);
                    if (moveLen > currentSpeed) {
                        moveX = (moveX / moveLen) * currentSpeed;
                        moveY = (moveY / moveLen) * currentSpeed;
                    }

                    // Zkus p≈ôesunout se (kontrola koliz√≠)
                    const enemyCollisionRadius = CONFIG.collision?.enemyRadius || 25;
                    if (!checkCollisionWithObstacles(enemy.worldX + moveX, enemy.worldY + moveY, enemyCollisionRadius)) {
                        enemy.worldX += moveX;
                        enemy.worldY += moveY;
                    } else {
                        // Pokud je tu kolize, zkus obej√≠t
                        if (!checkCollisionWithObstacles(enemy.worldX + moveX * 0.5, enemy.worldY + moveY, enemyCollisionRadius)) {
                            enemy.worldX += moveX * 0.5;
                            enemy.worldY += moveY;
                        } else if (!checkCollisionWithObstacles(enemy.worldX + moveX, enemy.worldY + moveY * 0.5, enemyCollisionRadius)) {
                            enemy.worldX += moveX;
                            enemy.worldY += moveY * 0.5;
                        }
                    }
                }
            });
        }
        
        // Aktualizace spojenc≈Ø
        function updateAllies() {
            allies.forEach((ally, index) => {
                if (ally.hp <= 0) return;
                
                // C√≠lov√° pozice
                const targetWorldX = world.offsetX;
                const targetWorldY = world.offsetY;
                
                const dx = targetWorldX - ally.worldX;
                const dy = targetWorldY - ally.worldY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Pohyb k hr√°ƒçi
                const followDistance = index === 0 ? 50 : 40;
                const allyCollisionRadius = CONFIG.collision?.allyRadius || 20;
                if (distance > followDistance) {
                    const moveX = (dx / distance) * ally.speed;
                    const moveY = (dy / distance) * ally.speed;

                    // Zkus p≈ôesunout se (kontrola koliz√≠)
                    if (!checkCollisionWithObstacles(ally.worldX + moveX, ally.worldY + moveY, allyCollisionRadius)) {
                        ally.worldX += moveX;
                        ally.worldY += moveY;
                    } else {
                        // Pokud je tu kolize, zkus obej√≠t - pohni se stranou
                        const perpX = -dy;
                        const perpY = dx;
                        const perpLen = Math.sqrt(perpX * perpX + perpY * perpY);

                        if (perpLen > 0) {
                            const sideX = (perpX / perpLen) * ally.speed * 0.7;
                            const sideY = (perpY / perpLen) * ally.speed * 0.7;

                            if (!checkCollisionWithObstacles(ally.worldX + sideX, ally.worldY + sideY, allyCollisionRadius)) {
                                ally.worldX += sideX;
                                ally.worldY += sideY;
                            } else {
                                // Zkus druh√Ω smƒõr
                                if (!checkCollisionWithObstacles(ally.worldX - sideX, ally.worldY - sideY, allyCollisionRadius)) {
                                    ally.worldX -= sideX;
                                    ally.worldY -= sideY;
                                }
                            }
                        }
                    }
                }
                
                // Lukost≈ôelec - √∫toƒç√≠ na robota
                if (index === 0 && ally.attackTimer < ally.attackCooldown) {
                    ally.attackTimer++;
                }
                
                if (index === 0 && ally.attackTimer >= ally.attackCooldown) {
                    // Najdi nejbli≈æ≈°√≠ho nep≈ô√≠tele
                    enemies.forEach(enemy => {
                        if (enemy.hp <= 0) return;
                        
                        const dx = enemy.worldX - ally.worldX;
                        const dy = enemy.worldY - ally.worldY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < ally.attackRange) {
                            // Vyst≈ôel ≈°√≠p
                            projectiles.push({
                                worldX: ally.worldX,
                                worldY: ally.worldY,
                                dx: dx / dist,
                                dy: dy / dist,
                                speed: 5,
                                damage: ally.damage,
                                target: enemy
                            });
                            ally.attackTimer = 0;
                        }
                    });
                }
                
                // L√©ka≈ô - l√©ƒç√≠ spojence
                if (index === 1) {
                    if (ally.healTimer > 0) {
                        ally.healTimer--;
                    }
                    
                    ally.attackTimer++;
                    if (ally.attackTimer >= ally.healCooldown) {
                        // Najdi zranƒõn√©ho spojence
                        allies.forEach(a => {
                            if (a.hp > 0 && a.hp < a.maxHp) {
                                a.hp = Math.min(a.hp + ally.healAmount, a.maxHp);
                                ally.healTimer = 30;
                                ally.attackTimer = 0;
                            }
                        });
                    }
                }
            });
        }
        
        // Aktualizace projektil≈Ø
        function updateProjectiles() {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                
                proj.worldX += proj.dx * proj.speed;
                proj.worldY += proj.dy * proj.speed;
                
                // Kontrola z√°sahu
                if (proj.target && proj.target.hp > 0) {
                    const dx = proj.target.worldX - proj.worldX;
                    const dy = proj.target.worldY - proj.worldY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 20) {
                        proj.target.hp -= proj.damage;
                        projectiles.splice(i, 1);
                        continue;
                    }
                }
                
                // Odstra≈à projektily mimo obrazovku
                const screenX = proj.worldX - world.offsetX + canvas.width / 2;
                const screenY = proj.worldY - world.offsetY + canvas.height / 2;
                
                if (screenX < -50 || screenX > canvas.width + 50 ||
                    screenY < -50 || screenY > canvas.height + 50) {
                    projectiles.splice(i, 1);
                }
            }
        }
        
        // Aktualizace UI
        function updateUI() {
            document.getElementById('archer-hp').textContent = Math.max(0, allies[0].hp);
            document.getElementById('healer-hp').textContent = Math.max(0, allies[1].hp);
            document.getElementById('robot-hp').textContent = Math.max(0, enemies[0].hp);
            document.getElementById('position').textContent = 
                `${Math.round(world.offsetX)}, ${Math.round(world.offsetY)}`;
        }
        
        // Aktualizace hry
        function update() {
            // Hr√°ƒç je v≈ædy na st≈ôedu, pohybujeme svƒõtem (kamera se pohybuje)
            const playerCollisionRadius = CONFIG.collision?.playerRadius || 20;

            if (keys['ArrowUp'] || keys['w'] || keys['W']) {
                const newOffsetY = world.offsetY - player.speed;
                if (!checkCollisionWithObstacles(0, -player.speed, playerCollisionRadius)) {
                    world.offsetY = newOffsetY;
                }
            }
            if (keys['ArrowDown'] || keys['s'] || keys['S']) {
                const newOffsetY = world.offsetY + player.speed;
                if (!checkCollisionWithObstacles(0, player.speed, playerCollisionRadius)) {
                    world.offsetY = newOffsetY;
                }
            }
            if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
                const newOffsetX = world.offsetX - player.speed;
                if (!checkCollisionWithObstacles(-player.speed, 0, playerCollisionRadius)) {
                    world.offsetX = newOffsetX;
                }
            }
            if (keys['ArrowRight'] || keys['d'] || keys['D']) {
                const newOffsetX = world.offsetX + player.speed;
                if (!checkCollisionWithObstacles(player.speed, 0, playerCollisionRadius)) {
                    world.offsetX = newOffsetX;
                }
            }
            
            updateEnemies();
            updateAllies();
            updateProjectiles();
            updateUI();
        }
        
        // Hlavn√≠ hern√≠ smyƒçka
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawGrid();
            drawObstacles();
            drawProjectiles();

            // Vykresli postavy
            drawRobot(enemies[0]);
            drawArcher(allies[0]);
            drawHealer(allies[1]);

            drawPlayer();
            
            update();
            
            requestAnimationFrame(gameLoop);
        }
        
        gameLoop();
    </script>
</body>
</html>